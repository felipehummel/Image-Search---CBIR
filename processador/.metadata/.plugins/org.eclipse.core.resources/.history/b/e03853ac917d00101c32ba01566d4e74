import java.io.FileInputStream;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map.Entry;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

import similarities.EuclidianDistanceSimilarity;
import similarities.ImageSimilarity;

public class Processor {
	public static final int HISTOGRAM_SIZE = 64*5*5;
	private final HashMap<Integer, int[]> images = new HashMap<Integer, int[]>(104000);
	private Entry<Integer, int[]>[] image_entries;
	public static final int TOP_K = 20;
	private final ExecutorService executor = Executors.newFixedThreadPool(3);
	
	@SuppressWarnings("unchecked")
	public void readData() throws IOException {
        FileInputStream inFile = null;
        inFile = new FileInputStream("/home/felipe/ufam/doutorado/ri/trab1_busca/output_binary_histograms");
        TextFile names_file = new TextFile("/home/felipe/ufam/doutorado/ri/trab1_busca/file_lookup_file");
        Iterator<String> names_iterator = names_file.iterator();
        FileChannel inChannel = inFile.getChannel();
        int[] ints;
        ByteBuffer buf = ByteBuffer.allocate(HISTOGRAM_SIZE*4);
        String name;
        int i = 0;
	    while (inChannel.read(buf) != -1) {
	    	ints = new int[HISTOGRAM_SIZE];
	    	((ByteBuffer) (buf.flip())).asIntBuffer().get(ints);
	        buf.clear();
	        name = names_iterator.next();
	        images.put(Integer.parseInt(name), ints);
	        if (i++%10000==0)
	        	System.out.println(i);
        }
        inFile.close();
        image_entries = (Entry<Integer, int[]>[]) new Entry[images.size()]; 
    	i = 0;
    	for (Entry<Integer, int[]> entry : images.entrySet()) {
    		image_entries[i] = entry;
			i++;
		}
        System.out.println(images.size()+  " imagens");
	}
	public ImageScore[] paralellProcessQueryImage(int query_image, ImageSimilarity similarity, int parallel_rate) throws InterruptedException, ExecutionException {
		ArrayList<Future<ImageScore[]>> futures = new ArrayList<Future<ImageScore[]>>(parallel_rate);
		int num_images = images.size();
		int shard_size = (int)Math.ceil((double)num_images / (double)parallel_rate);
		int lower = 0;
		int upper; 
		for (int i = 0; i < parallel_rate; i++) {
			if (shard_size + lower >= num_images)
				upper = num_images;
			else
				upper = shard_size + lower;
//			System.out.println(i+ " = ["+lower+", "+upper+"]");
			ShardProcessor shard = new ShardProcessor(images.get(query_image), lower, upper, image_entries, similarity);
			Future<ImageScore[]> result = executor.submit(shard);
			futures.add(result);
			lower += shard_size;
		}
		if (parallel_rate == 1)
			return futures.get(0).get();
		ImageScore[][] shard_scores = new ImageScore[parallel_rate][];
		ArrayList<ImageScore> scores = new ArrayList<ImageScore>(100);
		for (int i = 0; i < shard_scores.length; i++) {
			scores.addAll(Arrays.asList(futures.get(i).get()));
//			shard_scores[i] = futures.get(i).get();
		}
//		return mergeShardResults(shard_scores);
		Collections.sort(scores);
		return scores;
	}
	private ImageScore[] mergeShardResults(ImageScore[][] shard_scores) {
		int[] positions = new int[shard_scores.length];
		ImageScore[] final_results = new ImageScore[TOP_K];
		int greater_score_position = -1;
		float greater_score = -1;
		for (int i = 0; i < TOP_K; i++) {
			for (int j = 0; j < positions.length; j++) {
				if (shard_scores[j][positions[j]].score > greater_score) {
					greater_score = shard_scores[j][positions[j]].score;
					greater_score_position = j;
				}
			}
			final_results[i] = shard_scores[greater_score_position][positions[greater_score_position]];
			positions[greater_score_position]++;
		}
		return final_results;
	}
	
	public ImageScore[] processQueryImage(int query_image, ImageSimilarity similarity) {
		int id;
		int[] feature_array;
		int[] query_feature_array = images.get(query_image);
		float score;
		HitQueue pq = new HitQueue(TOP_K, true);
        ImageScore pqTop = pq.top();
		for (int i = 0; i < image_entries.length; i++) {
			id = image_entries[i].getKey();
			feature_array = image_entries[i].getValue();
			score = similarity.calculateSimilarity(feature_array, query_feature_array);
			if (score > pqTop.score) {
        		pqTop.id = id;
                pqTop.score = score;
                pqTop = pq.updateTop();
        	}
		}
		return Processor.getResults(pq);
	}
	
	
	public static ImageScore[] getResults(HitQueue x) {
		// In case pq was populated with sentinel values, there might be less
        // results than pq.size(). Therefore return all results until either
        // pq.size() or totalHits.
        //totalHits é igual a top_k pq a gente tem certeza que sempre vai ter top_K resultados no heap, ou seja não tem como sobrer objeto sentinel
        int totalHits = TOP_K; 
        int size = totalHits < x.size() ? totalHits : x.size();
        
        // We know that start < pqsize, so just fix howMany. 
        int howMany = Math.min(size, TOP_K);
        ImageScore[] results = new ImageScore[howMany];
        for (int i = howMany - 1; i >= 0; i--) {
            results[i] = x.pop();
        }
        return results;
	}
	
	private void shutDown() {
		executor.shutdownNow();
	}

	public static void main(String[] args) throws IOException {
		Processor proc = new Processor();
		proc.readData();
		
		try {
			long before = System.currentTimeMillis();
			ImageScore[] results = proc.processQueryImage(1234, new EuclidianDistanceSimilarity());
			long after = System.currentTimeMillis();
			System.out.println((after-before)+ " ms");
			System.out.println(Arrays.toString(results));
			
			before = System.currentTimeMillis();
			results = proc.paralellProcessQueryImage(1234, new EuclidianDistanceSimilarity(), 1);
			after = System.currentTimeMillis();
			System.out.println((after-before)+ " ms");
			System.out.println(Arrays.toString(results));
			
			before = System.currentTimeMillis();
			results = proc.paralellProcessQueryImage(1234, new EuclidianDistanceSimilarity(), 2);
			after = System.currentTimeMillis();
			System.out.println((after-before)+ " ms");
			System.out.println(Arrays.toString(results));
			
			before = System.currentTimeMillis();
			results = proc.paralellProcessQueryImage(1234, new EuclidianDistanceSimilarity(), 3);
			after = System.currentTimeMillis();
			System.out.println((after-before)+ " ms");
			System.out.println(Arrays.toString(results));
			
			
		} catch (InterruptedException e) {
			e.printStackTrace();
		} catch (ExecutionException e) {
			e.printStackTrace();
		}
		finally {
			proc.shutDown();	
		}
		
		
		
	}
	
	
}
